---
title: Complex Multiplication
description: Multiplication of two complex numbers in polar form
visible: true
approved: false
category: Complex Numbers and Trigonometric Functions
ord: 1
---
import ComplexMultiplication from "../../components/applets/ComplexMultiplication";
import MathBlock from "../../components/MathBlock";

# Complex Multiplication

<MathBlock type="definition" title="Complex Multiplication">
Using the polar form of complex numbers we can find a geometric interpretation of the multiplication of two complex numbers. For $z_1, z_2 \in \mathbb{C}$ with  
$z_1 = r_1 \cdot e^{i\varphi_1}$ and $z_2 = r_2 \cdot e^{i\varphi_2}$ with  
$r_1, r_2 \in (0,\infty)$ and $\varphi_1, \varphi_2 \in (-\pi,\pi]$, it holds that

$$
z := z_1 z_2 = r_1 r_2 e^{i(\varphi_1 + \varphi_2)} = r e^{i\varphi},
$$

i.e., we obtain the absolute value of $z$ by multiplying the absolute values of $z_1$ and $z_2$, and the angle $\varphi$ by adding the angles $\varphi_1$ and $\varphi_2$. This is illustrated in Figure 5.4.

Note that we may have $\varphi \notin (-\pi,\pi]$, so $\varphi$ may not be the principal value of $\arg(z)$.
</MathBlock>


---
<ComplexMultiplication client:load />
---


## Description
[Link to code](https://github.com/daniele-bolla/math-applets/blob/main/src/components/applets/ComplexMultiplication.tsx).

*Reference*: Lecture Notes Calculus 1 ( May22,2022 ) Figure 5.4 page 88

This applet visualizes complex multiplication using the polar interpretation. 
The axes represent the complex plane: the horizontal axis is $\mathrm{Re}(z)$ 
and the vertical axis is $\mathrm{Im}(z)$. Two draggable points represent 
the complex numbers $z_1$ and $z_2$, and the product $z=z_1z_2$ is shown as a third vector.

The points $z_1$ and $z_2$ are draggable. 
The product $z$ is defined from their Cartesian coordinates using the standard algebraic rule
$(a_1+ib_1)(a_2+ib_2)=(a_1a_2-b_1b_2)+i(a_1b_2+b_1a_2)$.
In code this is kept explicitly as
`Re(z) = z1.X()*z2.X() - z1.Y()*z2.Y()` and
`Im(z) = z1.X()*z2.Y() + z1.Y()*z2.X()`.
```ts
        const z = createPoint(board,
          [
            () => z1.X() * z2.X() - z1.Y() * z2.Y(),
            () => z1.X() * z2.Y() + z1.Y() * z2.X(),
          ],
          {
            name: "",
            fixed: true,
            withLabel: false,
          },
          Z_COLOR
        );
```

The three arrows from the origin (created with `board.create("arrow", [O, ...])`) 
represent the vectors $z_1$ (green), $z_2$ (red), and $z=z_1z_2$ (black). 
The colored angle sectors labeled $\varphi_1$, $\varphi_2$, and $\varphi$ 
(created with `board.create("angle", [U, O, ...])`) visualize their arguments.

To avoid an unstable argument near the origin, 
the applet constrains the draggable points so that $|z_1|$ and $|z_2|$ 
stay above a small minimum radius (`MIN_RADIUS`), enforced in `enforceMinRadius` during dragging.